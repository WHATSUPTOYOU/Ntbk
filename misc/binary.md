## 二进制文件信息查询

- ## ldd
> 作用：查询一个可执行文件或者共享库（动态链接库）所依赖的共享库
> 用法：**ldd target**

- ## nm
> 作用：列出库文件（.a、.lib）、目标文件（*.o）、可执行文件的符号表
> 用法：**nm target**

- ## strings
> 作用：在对象文件或二进制文件中查找可打印的字符串
> 用法：**string \[-n 6](字符最小长度) target**

- ## readelf
> 作用：查看ELF格式的文件信息
> 常用参数：
> > -h：显示elf文件开始的文件头信息
> > -S：显示节头信息 ``readelf -S target``
> > -s：显示符号表信息
> > -d：显示动态段的信息 `readelf -d target|grep NEEDED //查看运行所需的动态库`

- ## objdump
> 作用：将二进制文件、目标文件和共享库等各种可执行程序反汇编成汇编代码
> 常用参数：
> > -d：反汇编代码
> > -S：将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用-g参数，即需要调试信息；
> > -j：指定反汇编的段，`objdump -j .text -S target`
> >-h：获取elf文件节头

---

## 二进制文件处理

- ## xxd
> 作用：xxd命令可以为给定的标准输入或者文件做一次十六进制的输出，它也可以将十六进制输出转换为原来的二进制格式，即将任意文件转换为十六进制或二进制形式
> 用法：
>>二进制写入：`echo -e -n "\x11\x22" > test`  
>>- -e 反斜杠转义
>>- -n 不添加换行

>> 十六进制输出转二进制存储：`echo 001122334455 | xxd -r -ps > test`
>>- -r 十六进制输出转二进制内容
>>- -ps 连续十六进制转储

>>编辑二进制文件：``xxd target > tmp.txt `` && ``vi tmp.txt`` && ``xxd -r tmp.txt > res``，获得的res文件即为修改之后的文件
>>注：这种方式只能修改，如果需要添加字节，需要将后续的所有二进制数据重新对齐，否则会覆盖，可以使用**hexedit**等工具自动实现地址对齐

---

## 二进制代码调试
- ## gdb
> 要求：需要调试符号支持，编译成果物为debug版本（如C编译指定 -g 参数，Go编译指定参数 -gcflags "all=-N -l"）
> 
> 常用调试命令（[查看引用原文](https://blog.csdn.net/mayue_web/article/details/112197338)）：
> >l(list) 行号/函数名 —— 显示对应的code，每次10行
> r(run) —— F5【无断点直接运行、有断点从第一个断点处开始运行】
> b(breakpoint) + 行号 —— 在那一行打断点
> b 源文件：函数名 —— 在该函数的第一行打上断点
> b 源文件：行号 —— 在该源文件中的这行加上一个断点吧
> info b —— 查看断点的信息
> d(delete) + 当前要删除断点的编号 —— 删除一个断点【不可以d + 行号】
> d + breakpoints —— 删除所有的断点
> disable b(breakpoints) —— 使所有断点无效【默认缺省】
> enable b(breakpoints) —— 使所有断点有效【默认缺省】
> disable b(breakpoint) + 编号 —— 使一个断点无效【禁用断点】
> enable b(breakpoint) + 编号 —— 使一个断点有效【开启断点】
> enable breakpount —— 使一个断点有效【开启断电】
> n(next) —— 逐过程【相当于F10，为了查找是哪个函数出错了】
> s(step) —— 逐语句【相当于F11，】
> bt —— 看到底层函数调用的过程【函数压栈】
> set var —— 修改变量的值
> p(print) 变量名 —— 打印变量值
> display —— 跟踪查看一个变量，每次停下来都显示它的值【变量/结构体…】
> undisplay + 变量名编号 —— 取消对先前设置的那些变量的跟踪
> 
>> 排查问题三剑客
>>> until + 行号 —— 进行指定位置跳转，执行完区间代码
> finish —— 在一个函数内部，执行到当前函数返回，然后停下来等待命令
> c(continue) —— 从一个断点处，直接运行至下一个断点处【VS下不断按F5】

---

## 附录
ELF 常用Sections：
```
.text：已编译程序的机器代码。
.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。
.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。
.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。
.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。
.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。
.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。
.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。
.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。
.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。
